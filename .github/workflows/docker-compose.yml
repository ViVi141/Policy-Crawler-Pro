name: Docker Compose Build Test

on:
  push:
    branches:
      - main
      - master
      - develop
  pull_request:
    branches:
      - main
      - master

jobs:
  test-compose:
    name: Test Docker Compose
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Verify Docker Compose
        run: |
          echo "=== 验证 Docker Compose ==="
          # GitHub Actions runner 已预装 Docker Compose V2
          # 使用 'docker compose' (V2) 而不是 'docker-compose' (V1)
          docker compose version || (echo "❌ Docker Compose V2 不可用" && exit 1)
          echo "✅ Docker Compose V2 已就绪"

      - name: Build Docker Compose services
        run: |
          docker compose build --parallel

      - name: Start services
        run: |
          echo "=== 启动所有服务 ==="
          docker compose up -d
          
          echo "=== 等待数据库容器启动 ==="
          timeout 180 bash -c 'until docker compose ps db | grep -q "healthy"; do sleep 5; echo "等待数据库健康检查..."; done' || (echo "数据库启动超时" && docker compose logs db && exit 1)
          
          echo "=== 等待后端容器启动 ==="
          timeout 120 bash -c 'until docker compose ps backend | grep -q "healthy\|Up"; do sleep 3; echo "等待后端启动..."; done' || (echo "后端启动超时" && docker compose logs backend && exit 1)
          
          echo "=== 等待前端容器启动 ==="
          timeout 60 bash -c 'until docker compose ps frontend | grep -q "Up"; do sleep 2; echo "等待前端启动..."; done' || (echo "前端启动超时" && docker compose logs frontend && exit 1)
          
          echo "=== 等待服务完全就绪 ==="
          sleep 15

      - name: Check service health
        run: |
          echo "=== 检查容器状态 ==="
          docker compose ps
          
          echo "=== 检查数据库健康状态 ==="
          docker compose ps db | grep -q "healthy" || (echo "数据库未健康" && exit 1)
          
          echo "=== 检查后端健康状态（通过容器内部） ==="
          # 后端端口不暴露，通过容器内部访问
          timeout 120 bash -c 'until docker compose exec -T backend python -c "import urllib.request; urllib.request.urlopen(\"http://localhost:8000/api/health\").read()" 2>/dev/null; do sleep 3; echo "等待后端启动..."; done' || (echo "后端健康检查失败" && exit 1)
          
          echo "=== 检查前端健康状态 ==="
          # 前端绑定到 127.0.0.1:3000，使用 localhost 访问
          timeout 60 bash -c 'until curl -f http://127.0.0.1:3000/health; do sleep 2; echo "等待前端启动..."; done' || (echo "前端健康检查失败" && exit 1)
          
          echo "=== 检查前端访问后端 API（通过 Nginx 代理） ==="
          # 通过前端 Nginx 代理访问后端 API
          timeout 30 bash -c 'until curl -f http://127.0.0.1:3000/api/health; do sleep 2; echo "等待 API 代理就绪..."; done' || (echo "API 代理检查失败" && exit 1)
          
          echo "✅ 所有服务健康检查通过"

      - name: View logs
        if: failure()
        run: |
          echo "=== 数据库日志 ==="
          docker compose logs db --tail=50
          echo ""
          echo "=== 后端日志 ==="
          docker compose logs backend --tail=50
          echo ""
          echo "=== 前端日志 ==="
          docker compose logs frontend --tail=50
          echo ""
          echo "=== 所有容器状态 ==="
          docker compose ps -a

      - name: Run integration tests
        run: |
          echo "=== 运行集成测试 ==="
          
          # 测试前端页面
          echo "测试前端首页..."
          frontend_response=$(curl -s -w "\nHTTP_CODE:%{http_code}" http://127.0.0.1:3000/)
          frontend_code=$(echo "$frontend_response" | grep "HTTP_CODE" | cut -d: -f2)
          frontend_body=$(echo "$frontend_response" | grep -v "HTTP_CODE")
          if [ "$frontend_code" != "200" ]; then
            echo "❌ 前端首页返回非200状态码: $frontend_code"
            exit 1
          fi
          echo "$frontend_body" | grep -q "<!DOCTYPE html>" || (echo "❌ 前端首页不是有效的HTML" && exit 1)
          echo "$frontend_body" | grep -q "id=\"app\"" || (echo "❌ Vue应用根元素不存在" && exit 1)
          echo "✅ 前端首页加载正常"
          
          # 测试后端 API（通过前端代理）
          echo "测试后端健康检查 API（通过Nginx代理）..."
          api_response=$(curl -s -w "\nHTTP_CODE:%{http_code}" http://127.0.0.1:3000/api/health)
          api_code=$(echo "$api_response" | grep "HTTP_CODE" | cut -d: -f2)
          api_body=$(echo "$api_response" | grep -v "HTTP_CODE")
          echo "HTTP状态码: $api_code"
          echo "响应: $api_body"
          if [ "$api_code" != "200" ]; then
            echo "❌ API健康检查返回非200状态码: $api_code"
            exit 1
          fi
          echo "$api_body" | grep -q "healthy\|status" || (echo "❌ API健康检查响应格式错误" && exit 1)
          echo "✅ 后端健康检查API（通过代理）正常"
          
          # 测试后端 API（直接通过容器）
          echo "测试后端 API（容器内部直接访问）..."
          docker compose exec -T backend python -c "
          import urllib.request
          import json
          import sys
          try:
              response = urllib.request.urlopen('http://localhost:8000/api/health', timeout=10)
              data = json.loads(response.read().decode())
              if data.get('status') == 'healthy' or 'status' in data:
                  print('✅ 后端健康检查通过（容器内部）')
              else:
                  print(f'⚠️ 健康检查响应格式: {data}')
          except Exception as e:
              print(f'❌ 后端健康检查失败: {e}')
              sys.exit(1)
          " || (echo "❌ 后端容器内部API测试失败" && exit 1)
          
          # 测试API端点列表
          echo "测试其他API端点..."
          
          # 测试登录端点（需要POST，GET会返回405）
          echo "测试 /api/auth/login (POST)..."
          login_response=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X POST "http://127.0.0.1:3000/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{"username":"admin","password":"admin123"}')
          login_code=$(echo "$login_response" | grep "HTTP_CODE" | cut -d: -f2)
          if [ "$login_code" = "200" ]; then
            echo "✅ /api/auth/login 登录成功"
            # 提取token用于后续测试
            TOKEN=$(echo "$login_response" | grep -v "HTTP_CODE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4 || echo "")
            if [ -n "$TOKEN" ]; then
              export AUTH_TOKEN="$TOKEN"
              echo "✅ Token已提取"
            fi
          elif [ "$login_code" = "401" ]; then
            echo "⚠️ /api/auth/login 认证失败（可能默认用户不存在或密码错误）"
          else
            echo "⚠️ /api/auth/login 返回状态码: $login_code"
          fi
          
          # 测试其他端点（GET请求）
          endpoints=(
            "/api/tasks/"
            "/api/policies/"
            "/api/backups/"
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "测试 $endpoint..."
            # 如果有token，使用认证
            if [ -n "$AUTH_TOKEN" ]; then
              endpoint_response=$(curl -s -w "\nHTTP_CODE:%{http_code}" "http://127.0.0.1:3000$endpoint" \
                -H "Authorization: Bearer $AUTH_TOKEN")
            else
              endpoint_response=$(curl -s -w "\nHTTP_CODE:%{http_code}" "http://127.0.0.1:3000$endpoint")
            fi
            endpoint_code=$(echo "$endpoint_response" | grep "HTTP_CODE" | cut -d: -f2)
            # 401/403是预期的（需要认证），404可能表示路由不存在，500表示服务器错误
            if [ "$endpoint_code" -ge 500 ]; then
              echo "❌ $endpoint 返回服务器错误: $endpoint_code"
              exit 1
            elif [ "$endpoint_code" = "404" ]; then
              echo "⚠️ $endpoint 返回404（路由可能不存在）"
            elif [ "$endpoint_code" = "401" ] || [ "$endpoint_code" = "403" ]; then
              echo "✅ $endpoint 响应正常（需要认证）"
            elif [ "$endpoint_code" = "200" ]; then
              echo "✅ $endpoint 响应正常"
            else
              echo "⚠️ $endpoint 返回状态码: $endpoint_code"
            fi
          done
          
          # 测试Nginx代理重定向处理
          echo "测试Nginx代理重定向处理..."
          # 测试不带尾随斜杠的路径（应该被重定向到带斜杠的版本）
          # 使用 -L 跟随重定向，但先检查初始响应
          redirect_response=$(curl -s -w "\nHTTP_CODE:%{http_code}\nREDIRECT_URL:%{redirect_url}" -L --max-redirs 3 http://127.0.0.1:3000/api/tasks 2>&1)
          redirect_code=$(echo "$redirect_response" | grep "^HTTP_CODE" | cut -d: -f2)
          redirect_url=$(echo "$redirect_response" | grep "^REDIRECT_URL" | cut -d: -f2-)
          
          # 检查响应码（200表示成功，401表示需要认证，307/308表示重定向）
          if [ "$redirect_code" = "200" ] || [ "$redirect_code" = "401" ] || [ "$redirect_code" = "307" ] || [ "$redirect_code" = "308" ]; then
            echo "✅ 重定向处理正常（状态码: $redirect_code）"
            if [ -n "$redirect_url" ]; then
              echo "   重定向到: $redirect_url"
            fi
          elif [ "$redirect_code" = "404" ]; then
            echo "⚠️ 重定向处理返回404（端点可能不存在）"
          else
            echo "⚠️ 重定向处理返回状态码: $redirect_code"
            # 不退出，因为这不是关键测试
          fi
          
          # 测试容器间网络通信
          echo "测试容器间网络通信..."
          docker compose exec -T frontend curl -f http://backend:8000/api/health > /dev/null 2>&1
          if [ $? -eq 0 ]; then
            echo "✅ 前端容器可以访问后端容器"
          else
            echo "❌ 前端容器无法访问后端容器"
            exit 1
          fi
          
          echo "✅ 所有集成测试通过"

      - name: Stop services
        if: always()
        run: |
          echo "=== 停止所有服务 ==="
          docker compose down -v
